---
title: One-Click Payments
description: How Trails achieves one-confirmation payments leveraging any token from any chain.
icon: 'bolt'
---

## One-Confirmation Payments

Trails enables the following experience for developers & users:

- Execute any arbitrary payment (swap, mint, deposit, buy) on an app.
- Action or item can be priced in any token on any chain.
- Any bridges or swaps necessary to execute the payment are handled automatically.
- Users can select the desired token and from which chain they would like to execute the payment.

All of this happens with just **one user confirmation**, even if cross-chain bridging or token swapping is required behind the scenes, and regardless if they are using an EOA, account abstraction or smart wallet or 7702-enabled wallet.

Ultimately, this enhances the user experience of your application, optimizes your payment flows, and ensures more liquidity and volume to your app.

## How It Works

Trails enables one-click payments through a sophisticated intent-based architecture that handles complex cross-chain operations seamlessly. Here's how it works:

1. **User Initiates Payment**  
   The user clicks "Buy" or initiates any payment action on a dapp, triggering the Trails flow.

2. **Intent Address Generation**  
   A unique intent address is generated for this specific transaction. This address exists on both the origin and destination chains and contains predefined logic for handling the payment flow.

3. **Origin Deposit**  
   The user sends a single transaction to deposit their tokens (from any chain they hold funds on) into the intent address on the origin chain.

4. **Origin Chain Execution**  
   Relayer automatically executes an operation on the origin intent address, performing any necessary actions to move funds to the destination.

5. **Destination Chain Arrival**  
   The bridged funds arrive at the corresponding intent address on the destination chain, ready for the final execution.

6. **Final Settlement**  
   Relayer executes the final wallet operation on the destination intent address, completing the payment by sending funds to the recipient, executing any required contract calls, minting NFTs, or performing other specified actions.

This intent-based approach ensures that users only need to sign **one transaction** while the system handles all the complex routing, bridging, and settlement logic automatically across multiple chains.

## Example: Buy with Cross-Chain USDC

```ts
import { getClient } from "Trails";
import { createWalletClient, http } from "viem";

// Set up wallet (can be MetaMask, Sequence, embedded, etc.)
const wallet = createWalletClient({
  account: address,
  transport: http(),
});

// Bridge from Arbitrum to Optimism
const quote = await getClient()?.actions.getQuote({
  wallet,
  chainId: 7777777, // From Zora
  toChainId: 8453,  // To Base
  amount: '100000000000000000', // Amount in wei (e.g. 0.1 ETH)
  currency: '0x0000000000000000000000000000', // Token address on origin chain
  toCurrency: '0x0000000000000000000000000000', // Token address on destination
  recipient, // Destination address
});

await getClient()?.actions.execute({
  quote,
  wallet,
  onProgress: (steps, fees, currentStep, currentStepItem) => {
    console.log(steps, fees, currentStep, currentStepItem);
  }
});
