---
title: 1-Click Confirmations
description: How Trails achieves 1-click payments, swaps, funds, and yield opportunities leveraging any token from any chain for arbitrary executions.
icon: 'bolt-lightning'
---

## 1-Click Confirmations

Trails enables the following experience for users:

- Execute any arbitrary logic such as a swap, mint, deposit, buy on an app or chain.
- Action or asset can be priced in any token on any chain.
- Users can select any desired token from any chain from their balance to execute the payment.
- Any bridges, swaps, and execution logic necessary to execute the payment are handled automatically.

All of this happens with a single **one user confirmation**, even if cross-chain bridging or token swapping is required behind the scenes. Additionally, the user can utilize any wallet such as an EOA, account abstraction or
smart wallet, or embedded wallet. Trails does not require 7702-enabled wallets or chains, but does support them. Lastly, no contract changes are required to integrate.

Ultimately, this enhances and simplifies the user experience, optimizes your payment flows, and ensures more liquidity and volume to your app, chain, or protocol.

## How It Works

Trails enables 1-click payments through an intent-based architecture that is able to execute multiple transactions across multiple chains from a single user wallet confirmation with only a few lines of code. Here's how it works:

1. **User Initiates Payment**  
   The user clicks "Buy" or initiates any action requiring payment on a dapp, triggering the Trails flow.

2. **Intent Address Generation**  
   A unique intent contract address is computed based on the full transaction orchestration across multiple chains. The intent address encodes the details of both transactions on both the origin and destination
   chains.

3. **Origin Deposit**  
   The user sends a single transaction to deposit their tokens (from any chain they hold funds on) into the intent address on the origin chain. Importantly, the user's wallet has full control over this intent address.

4. **Origin Chain Execution**  
   Relayer automatically executes an operation on the origin intent address by submitting a merkle proof to execute the encoded origin transaction. The Relayer is unable to modify
   the transaction contents, it simply is able to trigger the execution of the encoded origin transaction. In fact, any party is able to safely trigger the intent transaction to move it forward.

5. **Destination Chain Arrival** 
   The bridged funds arrive at the corresponding intent address on the destination chain, ready for the final execution.

6. **Final Settlement**  
   Relayer executes the final wallet operation on the destination intent address by submitting a merkle proof to execute the encoded destination transaction, completing the payment by sending funds
   to the recipient, executing any required contract calls, or performing other specified actions.

This intent-based approach ensures that users only need to sign **one transaction** while the system handles all the complex routing, bridging, execution, and settlement logic automatically across multiple chains.

Lastly, Trails is extremely simple to integrate in a few lines of code in your app where all the heavy lifting is taken care of - all that needs to be specified is the payment parameters and any `calldata` to execute if desired.

## Example: Pay a recipient on Base in USDC with any token from any chain.

```ts
import { TrailsWidget } from '0xtrails'


export const CrossChainPayment = () => {
  return (
    <TrailsWidget
      toAddress="0x..." // recipient wallt address
      toAmount="0.1"
      toChainId={8453} // Base
      toToken="USDC"
    >
      <button className="custom-button-styles">
        Pay with Crypto
      </button>
    </TrailsWidget>
  )
}
```